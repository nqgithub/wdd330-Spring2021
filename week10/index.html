<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 10 Notes </title>
</head>

<body>

    <h1>Week 10</h1>

    <ul> <a href="/index.html">Home Page</a> </ul>

    <h2>Notes</h2>
    <p>From MDN Web Docs </p>
    <p>URL: https://developer.mozilla.org/</p>

    <body>
        <h4> Validating Forms and Using Fetch </h4>



        <section id="validatingForms">
            <h4> Client-side form validation </h4>
            <li> Before submitting data to the server, it is important to ensure all required form controls
                are filled out, in the correct format. This is called client-side form validation, and helps
                ensure data submitted matches the requirements set forth in the various form controls. T
                his article leads you through basic concepts and examples of client-side form validation. </li>
            <li> This is when you make sure the form is filled out before submitting it to the server </li>
            <li> Client-side form validation is very important. You should always have security measures in
                place to prevent bad data from going through to the server. </li>


            <h4> What is form validation? </h4>
            <li> There are many ways to validate a form and these are some of them. </li>
            <ul>"This field is required" (You can't leave this field blank).</ul>
            <ul>"Please enter your phone number in the format xxx-xxxx" (A specific data format is required for
                it to be considered valid).</ul>
            <ul>"Please enter a valid email address" (the data you entered is not in the right format).</ul>
            <ul>"Your password needs to be between 8 and 30 characters long and contain one uppercase letter,
                one symbol, and a number." (A very specific data format is required for your data).</ul>
            <li> When you enter data, the browser and/or the web server will check to see that the data is in the
                correct format and within the constraints set by the application. Validation done in the browser
                is called client-side validation, while validation done on the server is called server-side
                validation. </li>
            <li> There are two kinds of validation. The client-side or validation and the server-side of
                validation. </li>
            <li> brow </li>
            <li> If the form is filled out correctly it will be submitted to the server. If not it gives the user
                a reason of why it wasn't submitted and won't let them submit the form until the information is
                entered correctly. </li>
            <li> Why are people insistant on validating forms? Here are three main reasons. </li>
            <ul>1. We want to get the right data, in the right format. Our applications won't work properly if our
                users' data is stored in the wrong format, is incorrect, or is omitted altogether.</ul>

            <ul>2. We want to protect our users' data. Forcing our users to enter secure passwords makes it easier
                to protect their account information.</ul>

            <ul>3. We want to protect ourselves. There are many ways that malicious users can misuse unprotected
                forms to damage the application</ul>


            <h4> Different types of client-side validation </h4>
            <li> There are two different types of client-side validation that you'll encounter on the web: </li>
            
            <h5>Built-in form validation:</h5>
            <ul> Built-in form validation: Built-in form validation uses HTML5 form validation features. </ul>
            <ul> This validation generally doesn't require much JavaScript. Built-in form validation has better 
                performance than JavaScript, but it is not as customizable as JavaScript validation. </ul>
            
            <h5>JavaScript validation:</h5>
            <ul>JavaScript validation is coded using JavaScript. This validation is completely customizable, but you 
                need to create it all (or use a library).</ul>
           
            <h4> Using built-in form validation </h4>
            <ul> Required: Specifies whether a form field needs to be filled in before the form can be submitted. </ul>
   
            <ul> Minlength and maxlength: Specifies the minimum and maximum length of textual data (strings) </ul>
   
            <ul> Min and max: Specifies the minimum and maximum values of numerical input types </ul>
   
            <ul> Type: Specifies whether the data needs to be a number, an email address, or some other specific preset type. </ul>
   
            <ul> Pattern: Specifies a regular expression that defines a pattern the entered data needs to follow. </ul>
            
            <li> If the data entered in a form field follows all of the rules specified by the above attributes, it is 
                considered valid. If not, it is considered invalid. </li>


        </section>

<br>
<br>
<br>

        <section>
            <h4> Using Fetch </h4>
            <li> The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, 
                such as requests and responses. It also provides a global fetch() method that provides an easy, logical 
                way to fetch resources asynchronously across the network. </li>
            <li> This kind of functionality was previously achieved using XMLHttpRequest. Fetch provides a better 
                alternative that can be easily used by other technologies such as Service Workers. Fetch also provides a 
                single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP. </li>
            <li> In other words, fetch allows you to reach anywhere on the network (as long as you have access to it) and 
                get data </li>
            <li>The fetch() command won’t reject on HTTP error status even if the response is an HTTP 404 or 500. Instead, 
                as soon as the server responds with headers, the Promise will resolve normally (with the ok property of the 
                response set to false if the response isn’t in the range 200–299), and it will only reject on network failure 
                or if anything prevented the request from completing. </li>
            <li> The fetch() command also won’t send cross-origin cookies unless you set the credentials init option. </li>
            
            <br> 
            <img src="/week10/week10Pictures/fetch-1_result.jpg" alt="fetch-1 Picture">
            <br>
            
            <li> Here we are fetching a JSON file across the network and printing it to the console. The simplest use of 
                fetch() takes one argument — the path to the resource you want to fetch — and returns a promise containing 
                the response (a Response object). </li>
            <li> This is just an HTTP response, not the actual JSON. To extract the JSON body content from the response, 
                we use the json() method (defined on the Body mixin, which is implemented by both the Request and Response 
                objects.) </li>

        </section>



    </body>


    <br>

    <h4>-------- Questions --------</h4>
    <li> None Avalible</li>

    <p>------------------------------</p>

    <br>

    <p>------------------------------</p>
    <h4>Team Activity </h4>
    <h5>Please click the link below.</h5>

    <a href="/week10/teamActivity/index.html">Week 10 Team Activity</a>

    <!-- <a href="/week9/teamActivity/javascripts-drums/index-START.html">Week 9 Team Activity</a> -->

    <p>------------------------------</p>


    <br>
    <br>





</body>

</html>